# -*- coding: utf-8 -*-

"""
pywebcopy.elements
~~~~~~~~~~~~~~~~~~

Asset elements of a web page.

"""

<<<<<<< HEAD
import re
import sys
from os import path
from uuid import uuid4
from mimetypes import guess_extension
from pywebcopy import LOGGER
from pywebcopy.config import config
from pywebcopy.urls import Url, url2path
from pywebcopy.urls import filename_present
from pywebcopy import utils
from pywebcopy.urls import pathname2url
from pywebcopy.exceptions import InvalidUrlError
from pywebcopy.core import get
from pywebcopy.core import new_file

PY3 = (sys.version_info[0] == 3)
CSS_URLS = re.compile(b'''url\\(['|"]?(.*?)["|']?\\)''')


class FileMixin(Url):
    """Wrapper for every Asset type which is used by a web page. e.g. css, js.

     It inherits the Url() object to provide file path manipulations.
     """

    default_filename = str(uuid4())[:10] + '.download'

    def __init__(self, url):
        super(FileMixin, self).__init__(url)
        # this file needs to go in the project_folder to be able to correctly used by
        # the html file
        self.base_path = config['project_folder']

    def _save_file(self):
        """Saves the file from url and returns the file location. """

        # Pass the url to default downloader and will suppress and suppress any
        # error generated by the downloader
        new_file(content_url=self.url, location=self.file_path)
        LOGGER.info("Saved the file successfully to the location %s" % self.file_path)

    def save_file(self):
        """Saves the file in background thread."""
        self._save_file()


class Asset(FileMixin):
    """Wrapper for unknown Asset types which is used for unknown url types
    which are automatically detected and saved."""

    def __init__(self, url):
        self.req = None
        super(Asset, self).__init__(url)

    def _request(self):
        """Returns HTTP request object."""

        self.req = get(self.url, stream=True)

        if not self.req or not self.req.ok:
            LOGGER.error("Server returned error for the url %s" % self.url)
            raise InvalidUrlError("Server returned error for the url %s" % self.url)
        return self.req

    def _contentType(self):
        """Return the content-type as seen on request headers or a default type."""
        return self.req.headers.get('content-type') if self.req else ''

    def _fnCheck(self):
        """Checks if filename is present, if not then generate a default one."""
        # A default filename is generated based on url in case the file path doesn't have
        # a filename could create errors when writing files.
        if not filename_present(self.url):
            # we will get the mime-type of this file and try to guess the file extension
            # then we will create a random filename with the guessed file extension
            # which will not create an error during saving of the file

            _guess_ext = guess_extension(self._contentType(), strict=False) or '.download'
            _filename = str(uuid4()) + _guess_ext
            self.default_filename = _filename

    def save_file(self):
        """Saves this file after detection of type and generating a suitable default filename."""

        req = self._request()

        # now since a default filename is set then we will move to saving this file
        path = new_file(content=req.content or b"File couldn't be downloaded!.", location=self.file_path)
        LOGGER.info("Saved the file successfully to the location %s" % path)
        return path


class AnchorTag(FileMixin):
    """Customises the FileMixin() object for Anchor Tags"""

    default_filename = "index.html"

    def __init__(self, url):

        super(AnchorTag, self).__init__(url)

    def save_file(self):
        pass


class LinkTag(FileMixin):
    """Customises the FileMixin() object for css file type."""

    def __init__(self, url):
        
        # Random 50 chars long file name
        self.default_filename = "%s.css" % str(uuid4())[:15]

        super(LinkTag, self).__init__(url)


    @staticmethod
    def extract_css_urls(url_obj, contents=None):
        """
        Extracts url() links in css and saves and
        replaces them in file
        all the linked file url() will be saved and file path
        would be replaced accordingly

        """

        if not contents:
            try:
                # read the file
                LOGGER.debug('Reading Existing file at %s' % url_obj.file_path)
                contents = open(url_obj.file_path, 'rb').read()
                LOGGER.debug('Finding CSS urls in file %s' % url_obj.file_path)

            except Exception as e:
                LOGGER.critical(e)
                LOGGER.critical('Failed to open file %s for CSS urls search' % url_obj.file_path)
                return

        # the regex matches all those with double mix-match quotes and normal ones
        # also have to strip down the mix match quotes
        _urls = CSS_URLS.findall(contents)

        # if links are not found
        if len(_urls) == 0:
            LOGGER.info('No CSS linked files are found in file %s' % url_obj.file_path)
            return contents

        # links are found, now extract and save them
        LOGGER.info('%d CSS linked files are found in file %s' % (len(_urls), url_obj.file_path))

        for _url in _urls:
            # Urls may have double unequal quotes which is due to re pattern limitation
            # urls are in bytes format which creates error when doing url operations
            # thus have to be suppressed
            try:
                _str_url = _url.encode('utf8')
            except Exception as e:
                LOGGER.debug(e)
                LOGGER.debug("Conversion to unicode failed for the url %r" % _url)
                continue

            # url can be base64 encoded content which is not required to be stored
            if _str_url[:4] == 'data':
                continue

            try:
                # a path is generated by the cssAsset object and tried to store the file
                # but file could be corrupted to open or write
                _obj = Asset(_str_url)
                _obj.base_url = url_obj.url
                _obj.base_path = config['project_folder']
                _obj.save_file()

            except Exception as e:
                LOGGER.error(e)
                LOGGER.error("Error while searching CSS file! A File failed to be Saved of url %s" % _str_url)
                continue

            # generate a relative path for this downloaded file
            _rel_url = pathname2url(utils.relate(
                _obj.file_path, url_obj.file_path
            ))
            LOGGER.debug('Replacing linked file path %s by %s' % (_str_url, _rel_url))

            # save the location of the downloaded file on the original file
            if sys.version_info[0] == 3:
                # reconvert to bytes
                _rel_url = bytes(_rel_url, "utf-8")
                contents = contents.replace(_url, _rel_url)
            else:
                _rel_url = bytes(_rel_url)
                contents = contents.replace(_url, _rel_url)

        if not contents:
            # if the search was in a pre-existing file then
            # rewrite the original file to contain the newly downloaded file links
            with open(url_obj.file_path, 'wb') as orig_file:
                orig_file.write(contents)

        else:
            # otherwise return the rewritten bytes contents
            return contents

    def save_file(self):
=======
import os
import re
import sys
import threading
from threading import Thread

from six.moves.urllib.request import pathname2url

from . import LOGGER, utils
from .configs import config
from .urls import URLTransformer
from .core import get, new_file


_main = threading.current_thread
_enumerate = threading.enumerate

PY3 = (sys.version_info[0] == 3)

CSS_URLS = re.compile(b'''url\\(['"]?(.*?)["']?\\)''')
"""Matches any url() declaration in a css file."""

CSS_IMPORTS = re.compile(b'''@import\\s*['"](.*?)['"]\\s*''')
"""Matches any @import declaration in a css file."""


class FileMixin(URLTransformer, Thread):
    """Wrapper for every Asset type which is used by a web page. e.g. css, js, img, link.

     It inherits the URLTransformer() object to provide file path manipulations.

     :type url: str
     :type base_url: str
     :param str url: a url type string for working
     :param optional str base_url: base url of the website i.e. domain name
     :param optional str base_path: base path where the files will be stored after download
     """
    rel_path = None     # Initialiser for a dummy use case

    def __init__(self, url, base_url=None, base_path=None):
        # this file needs to go in the project_folder to be able to correctly used by
        # the html file
        URLTransformer.__init__(self, url, base_url, base_path)
        Thread.__init__(self)

    def run(self):
        """Saves the file from url and returns the file location. """

        # The file path provided can already be existing
        if os.path.exists(self.file_path) and not config['over_write']:
            LOGGER.info("File already exists at location: {!r}".format(self.file_path))
            return

        new_file(content_url=self.url, location=self.file_path)

    def save_file(self):
        """Saves the file in background thread."""
        self.start()


class AnchorTag(FileMixin):
    """Customises the FileMixin() object for Anchor Tags"""

    def __init__(self, *args, **kwargs):
        super(AnchorTag, self).__init__(*args, **kwargs)

        self.default_filename = 'index.html'
        self.default_fileext = 'html'
        self.check_fileext = True

    def run(self):
        # Override the saving action the file object
        return


class LinkTag(FileMixin):
    """Customises the FileMixin() object for css file type.

    :param bytes contents: contents of the file to be written to disk
    """
    contents = b''  # binary file data
    files = []       # sub-files counter

    def repl(self, match_obj):
        """Processes an url and returns a suited replaceable string.

        :type match_obj: re.MatchObject
        :param match_obj: regex match object to be processed
        :rtype: str
        :return: processed url
        """
        url = match_obj.group(1)

        # url can be base64 encoded content which is not required to be stored
        if url[:4] == b'data':
            return url

        # a path is generated by the cssAsset object and tried to store the file
        # but file could be corrupted to open or write
        # NOTE: self.base_path property needs to be set in order to work properly
        if self.base_path:
            base_path = self.base_path
        else:
            base_path = config['project_folder']

        # decode the url
        str_url = url.decode()

        # If the url is also a css file then it that file also
        # needs to be scanned for urls.
        if str_url.endswith('.css'):
            new_element = LinkTag(str_url, self.url, base_path)

        else:
            new_element = FileMixin(str_url, self.url, base_path)

        # Start the download of the file
        new_element.start()
        self.files.append(new_element)

        # generate a relative path for this downloaded file
        url = pathname2url(utils.relate(new_element.file_path, self.file_path))

        return "url({})".format(url).encode()

    def extract_css_urls(self):
        """Extracts url() links and @imports in css.

        All the linked files will be saved and file path
        would be replaced accordingly
        """

        # the regex matches all those with double mix-match quotes and normal ones
        self.contents = CSS_URLS.sub(self.repl, self.contents)
        self.contents = CSS_IMPORTS.sub(self.repl, self.contents)

        # log amount of links found
        LOGGER.info('%d CSS linked files are found in file %s' % (len(self.files), self.file_path))

        # wait for the still downloading files
        for t in self.files:
            if t is _main():
                continue
            t.join()

        # otherwise return the rewritten bytes self.contents
        return self.contents

    def run(self):
>>>>>>> v5.0.0
        """Css files are saved differently because they could have url() files in them which also links
        for different files. Thus css file content needs to be searched for urls and then it will proceed
        as usual."""

<<<<<<< HEAD
        # LinkTags can also be specified for elements like favicon etc. Thus a check is neccessary
        # to validate it is a proper css file or not.
        if not self.file_name.endswith('.css'):
            super(LinkTag, self).save_file()

        # Custom request object creation
        req = get(self.url)

        # if some error occurs
        if not req or not req.ok:
            raise InvalidUrlError("Url returned an unknown response %s" % self.url)

        # Send the contents for urls
        content = self.extract_css_urls(contents=req.content.decode(req.encoding), url_obj=self)

        # Save the content peacefully
        new_file(location=self.file_path, content=content.encode('iso-8859-1', errors='ignore'))


class ScriptTag(FileMixin):
    """Customises the Asset() object for css file type."""

    def __init__(self, url):
        # Random 50 chars long file name
        self.default_filename = "%s.js" % str(uuid4())[:15]
        super(ScriptTag, self).__init__(url)

=======
        # LinkTags can also be specified for elements like favicon etc. Thus a check is necessary
        # to validate it is a proper css file or not.
        if not self.file_name.endswith('.css'):
            super(LinkTag, self).run()

        # Custom request object creation
        req = get(self.url, stream=True)

        # if some error occurs
        if not req or not req.ok:
            LOGGER.error("URL returned an unknown response %s" % self.url)
            return

        # Send the contents for urls
        self.contents = req.content

        # Find and save any urls  or imports in css file
        self.extract_css_urls()

        # Save the content with original encoding
        new_file(location=self.file_path, content=self.contents)


class ScriptTag(FileMixin):
    """Customises the Asset() object for js file type."""
>>>>>>> v5.0.0


class ImgTag(FileMixin):
    """Customises the Asset() object for images file type."""
<<<<<<< HEAD

    def __init__(self, url):
        # Random 50 chars long file name
        self.default_filename = "%s.jpg" % str(uuid4())
        super(ImgTag, self).__init__(url)



=======
>>>>>>> v5.0.0
