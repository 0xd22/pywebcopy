# encoding: utf-8
"""
pywebcopy.webpage
~~~~~~~~~~~~~~~~~

Python form of a webpage.

Usage::

    >>> from pywebcopy import Webpage, config
    >>> url = 'http://some-url.com/some-page.html'

    # You should always start with setting up the config or use apis
    >>> config.setup_config(url, project_folder, project_name, **kwargs)

    # Create a instance of the webpage object
    >>> wp = Webpage()

    # If you want to use `requests` to fetch the page then
    >>> wp.get(url)

    # Else if you want to use plain html or urllib then use
    >>> wp.set_source(object_which_have_a_read_method, encoding=encoding)
    >>> wp.url = url   # you need to do this if you are using set_source()

    # Then you can access several methods like
    >>> wp.save_complete()
    >>> wp.save_html()
    >>> wp.save_assets()

"""

import os

import requests
import six

from . import LOGGER, SESSION
from .configs import config
from .exceptions import InvalidUrlError, ParseError
from .parsers import BaseIncrementalParser
from .urls import URLTransformer


class BaseWebPage(BaseIncrementalParser):
    """Extensible base parser for use with external data.
    Implements the apis which foresees the data source
    registration and element handler managements.
    """

    def __init__(self):
        super(BaseWebPage, self).__init__()

        self._url = None
        self._url_obj = None

    @property
    def url(self):
        return self._url

    @url.setter
    def url(self, new_url):
        self._url = new_url
        self._url_obj = None

    @property
    def utx(self):
        """Returns an URLTransformer() object made from the self.url string.

        :rtype: URLTransformer
        :returns: prepared URLTransformer object
        """
        if self._url_obj is None:
            assert self._url is not None, "Url not setup."
            assert config.get('project_folder', None) is not None, "Configuration not setup."

            self._url_obj = URLTransformer(
                url=self._url,
                base_url=self._url,
                base_path=config['project_folder'],
                default_fn='index.html'
            )
            self._url_obj.default_fileext = 'html'
            self._url_obj.check_fileext = True

        return self._url_obj

    def get_source(self):
        """Returns the resources set for this object.
        This method can be overridden to provide alternate way of source loading."""

        if not self._source or not hasattr(self._source, 'read'):
            raise ParseError("Source is not defined or doesn't have a read method!")
        return self._source

    def set_source(self, source, encoding=None, base_url=None):
        """Sets up the resource for this object."""
        if not hasattr(source, 'read'):
            try:
                source = open(source, 'rb', encoding=encoding)
            except OSError:
                raise ParseError("Provided source neither have a read method "
                                 "nor is a file path."
                                 "Use a File like object or provide a correct file name.")
        if not hasattr(source, 'read'):
            TypeError("Provide a file like object with `read` method!")
        if base_url:
            assert isinstance(base_url, six.string_types), "Url must be a string!"
            self._url = base_url
            self._url_obj = None
        self._source = source
        self.encoding = encoding

    def save_assets(self, base_path=None):
        """Save only the linked files to the disk.

        :param str base_path: folder in which to store the files.
        """
        if self.root is None:
            self.__parse__()
            if not self.root:
                raise ParseError("Tree is not being generated by parser!")

        LOGGER.action("Starting save_assets Action on url: {!r}".format(self.utx.url))

        if base_path:
            if not os.path.isdir(base_path):
                raise ValueError("Provided path is not a valid directory! %s" % base_path)
            self.utx.base_path = base_path

        for file in self:
            if not hasattr(file, 'start'):
                LOGGER.error("Downloading for file %r cannot be started!" % file)
                continue
            file.start()

    def save_html(self, file_name=None, raw_html=False):
        """Saves the html of the page to a default or specified file.

        :param str file_name: path of the file to write the contents to
        :param bool raw_html: whether write the unmodified html or the rewritten html
        """
        if self.root is None:
            self.__parse__()  # call in the action

        LOGGER.action("Starting save_html Action on url: {!r}".format(self.utx.url))

        # Create directories if neccessary
        if not os.path.exists(os.path.dirname(file_name)):
            os.makedirs(os.path.dirname(file_name))

        if raw_html:
            with open(file_name, 'wb') as fh:
                fh.write(self.get_source().read())
        else:
            if self.root is None:
                self.__parse__()
                if not self.root:
                    raise ParseError("Tree is not being generated by parser!")
            self.root.getroottree().write(file_name, method="html")

    def save_complete(self):
        """Saves the complete html+assets on page to a file and
        also writes its linked files to the disk.

        Implements the combined logic of save_assets and save_html in
        compact form with checks and validation.
        """

        assert self.url is not None, "Url is not setup."
        assert self.get_source() is not None, "Source is not setup."

        LOGGER.action("Starting save_complete Action on url: {!r}".format(self.url))

        if self.root is None:
            self.__parse__()  # call in the action

        self.save_assets()
        self.save_html(self.utx.file_path, raw_html=False)


class WebPage(BaseWebPage):
    """Provides the apis for invoking parse and save functionalities.

    usage::

        >>> from pywebcopy import Webpage, config
        >>> url = 'http://some-url.com/some-page.html'

        # You should always start with setting up the config or use apis
        >>> config.setup_config(url, project_folder, project_name, **kwargs)

        # Create a instance of the webpage object
        >>> wp = Webpage()

        # If you want to use `requests` to fetch the page then
        >>> wp.get(url)

        # Else if you want to use plain html or urllib then use
        >>> wp.set_source(object_which_have_a_read_method, encoding=encoding)
        >>> wp.url = url   # you need to do this if you are using set_source()

        # Then you can access several methods like
        >>> wp.save_complete()
        >>> wp.save_html()
        >>> wp.save_assets()

    """

    def __init__(self, **kwargs):
        super(WebPage, self).__init__()

        # Some scripts might have apis specific to previous verion which this doesn't support
        # now and would definitely remove the arguments in later version
        if 'url' in kwargs or kwargs:
            raise DeprecationWarning("Direct initialisation with url is not supported now. Please use"
                                     "the get() or set_source() methods for page fetching."
                                     "And use the config.setup_config() method to setup the kwargs."
                                     "Arguments will be completly removed in later versions.")

    def __repr__(self):
        return '<WebPage: %s>' % self.url

    def get(self, url, use_global_session=True, **requestskwargs):
        """Fetches the Html content from Internet using the requests.
        You can any requests params which will be passed to the library
        itself.
        The requests arguments you supply will also be applied to the
        global session meaning all the files will be downloaded using these
        settings.

        If you want to use some manual page fetch, like using urllib, then
        you should use the set_source() method which would do the right job.

        usage::

            >>> wp = WebPage()
            >>> wp.get(url, proxies=proxies, headers=headers, auth=auth, ...)
            >>> wp.save_complete()

        :param url: url of the webpage to fetch
        :param use_global_session: if you would like later http requests made to server to follow the
            same configuration as you provided then leave it to 'True' else if you want
            only single http request to follow these configuration set it to 'False'.
        :param \*\*requestskwargs: keyword arguments which `requests` module may accept.
        """
        if use_global_session:
            req = SESSION.get(url, stream=True, **requestskwargs)
        else:
            req = requests.get(url, stream=True, **requestskwargs)
        if not req.ok:
            raise InvalidUrlError("Url invalid :  %s" % url)

        # Set some information about the content being loaded so
        # that the parser has a better idea about
        self._url, self.encoding = req.url, req.encoding
        self._url_obj = None
        # The internal parser assumes a read() method to be
        # present on the source, thus we need to pass the raw stream
        # io object which serves the purpose
        req.raw.decode_content = True
        self.set_source(req.raw)
